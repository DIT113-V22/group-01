# Smartcar shield library documentation
Welcome to the Smartcar shield library. These pages are intended to provide information
on how to use the library's API with explanations and examples for every exposed method.

If you are viewing this as source code or as a single page on
[github.com](https://github.com/platisd/smartcar_shield),
please go to the dedicated documentation pages on
[github.io](https://platisd.github.io/smartcar_shield/). These pages are
automatically generated by [Doxygen](http://www.doxygen.nl) and
[Travis CI](https://travis-ci.org/) after every commit, meaning that they are
the most probable source of up-to-date documentation.

Click on the [Classes](https://platisd.github.io/smartcar_shield/annotated.html)
tab for documentation on the various classes and
[Files](https://platisd.github.io/smartcar_shield/files.html) for an overview of
the dependencies between the different packages.

## About the library
The library sports a high level API, meant to enable its users to perform tasks
easily with relatively few lines of code. It intends to hide implementation
details or low level hardware operations. The library, handles the various
components (i.e. the vehicle and the various sensors) as objects, therefore
enabling trivial control over the car's functions.

The examples are primarily tailored to be used with the
[Smartcar Shield](https://github.com/platisd/smartcar_shield/tree/master/extras/eagle/smartcar_shield)
which was the hardware initially coupled with this software. However, by using different
arguments the different classes can be reused with practically any Motor and Control
combination common to miniature vehicles. Additionally, a plethora of hobby-grade
sensors are supported which potentially makes this library the only external component
necessary for many robotic or autonomous driving use cases, when it comes to
programming the microcontroller.

## Extending the library
All classes implement an interface which allow you to create library extensions
and give you the possibility of writing code that can be reused among different
platforms and hardware setups. Furthermore, despite the library written for
Arduino-compatible microcontrollers, potentially any microcontroller could be used
by providing your own implementation of the Runtime interface.
